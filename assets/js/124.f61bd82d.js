(window.webpackJsonp=window.webpackJsonp||[]).push([[124],{582:function(t,i,a){"use strict";a.r(i);var v=a(0),_=Object(v.a)({},(function(){var t=this,i=t._self._c;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h2",{attrs:{id:"taskaffinity"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#taskaffinity"}},[t._v("#")]),t._v(" taskAffinity")]),t._v(" "),i("blockquote",[i("p",[t._v("每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。")])]),t._v(" "),i("p",[t._v('android:taskAffinity="" ，在AndoridManifest.xml文件中作为Activity的属性使用。')]),t._v(" "),i("p",[i("strong",[t._v("先检查包名是否相同，然后检查taskAffinity是否相同，如果都相同，intent的flag设置为flag_activity_new_task的activity与启动它的activity入同一个栈，否则建立新的task然后入栈。")])]),t._v(" "),i("h2",{attrs:{id:"task"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#task"}},[t._v("#")]),t._v(" Task")]),t._v(" "),i("p",[t._v("Task就是一个任务栈，里面用来存放Activity，第一个进去的（Activity）处于栈的最下面，而最后创建的（Activity）则处于栈的最上面。从Task中取出（Activity）是从最顶端取出，也就是说先进后出，后进先出。而Activity在Task中的顺序是可以控制的，在Activity跳转时用到Intent Flag可以设置新建Activity的创建方式。")]),t._v(" "),i("h2",{attrs:{id:"activity-intent-flag"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#activity-intent-flag"}},[t._v("#")]),t._v(" Activity Intent FLAG")]),t._v(" "),i("ul",[i("li",[i("p",[i("strong",[t._v("FLAG_ACTIVITY_NEW_TASK")])]),t._v(" "),i("p",[t._v("先检查包名是否相同，然后检查taskAffinity是否相同，如果都相同，intent的flag设置为flag_activity_new_task的activity与启动它的activity入同一个栈，否则建立新的task然后入栈。")])]),t._v(" "),i("li",[i("p",[i("strong",[t._v("FLAG_ACTIVITY_CLEAR_TASK")])]),t._v(" "),i("p",[t._v("会导致含有待启动Activity的Task在Activity被启动前清空。也就是说，这个Activity会成为一个新的root，并且所有旧的activity都被finish掉。这个标志只能与FLAG_ACTIVITY_NEW_TASK 一起使用。")])]),t._v(" "),i("li",[i("p",[i("strong",[t._v("FLAG_ACTIVITY_SINGLE_TOP")])]),t._v(" "),i("p",[t._v("相当于LaunchMode中的SingleTop模式")])]),t._v(" "),i("li",[i("p",[i("strong",[t._v("FLAG_ACTIVITY_CLEAR_TOP")])]),t._v(" "),i("p",[t._v("相当于LaunchMode中的SingleTask模式")])]),t._v(" "),i("li",[i("p",[i("strong",[t._v("FLAG_ACTIVITY_NO_HISTORY")])]),t._v(" "),i("p",[t._v("使用这个FLAG启动的Activity一但退出，就不会存在于栈中。（即，不存在历史记录）")])]),t._v(" "),i("li",[i("p",[i("strong",[t._v("FLAG_ACTIVITY_NO_USER_ACTION")])]),t._v(" "),i("p",[t._v("使用这个FLAG启动的Activity，可以在避免用户离开当前Activity时回调到 onUserLeaveHint()。")])]),t._v(" "),i("li",[i("p",[i("strong",[t._v("FLAG_ACTIVITY_BROUGHT_TO_FRONT")])]),t._v(" "),i("p",[t._v("task中顺序ABC时，由C启动B并设置intent FLAG为此，则顺序变为ACB。")])])]),t._v(" "),i("h2",{attrs:{id:"拓展"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#拓展"}},[t._v("#")]),t._v(" 拓展")]),t._v(" "),i("p",[i("strong",[t._v("onUserLeaveHint()：")])]),t._v(" "),i("p",[t._v("作为Activity的生命周期回调的部分，会在用户决定将Acitivity放到后台时被调用。例如：当用户按下Home键，onUserLeaveHint就会被调用。但是当来电话时，来电界面会自动弹出，onUserLeaveHint就不会被调用。当该方法被调用时，他会恰好在onPause调用之前。")]),t._v(" "),i("p",[t._v("本文转自 "),i("a",{attrs:{href:"http://events.jianshu.io/p/6c449ca2499a",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://events.jianshu.io/p/6c449ca2499a"),i("OutboundLink")],1),t._v("，如有侵权，请联系删除。")])])}),[],!1,null,null,null);i.default=_.exports}}]);