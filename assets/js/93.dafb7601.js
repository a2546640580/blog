(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{546:function(t,s,v){"use strict";v.r(s);var _=v(0),a=Object(_.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"java成员变量、局部变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java成员变量、局部变量"}},[t._v("#")]),t._v(" Java成员变量、局部变量")]),t._v(" "),s("hr"),t._v(" "),s("hr"),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/shug666/image/main/images/20200512215157577.png",alt:""}})]),t._v(" "),s("p",[t._v("1）静态变量只会初始化（执行）一次。")]),t._v(" "),s("p",[t._v("2）当有父类时，完整的初始化顺序为：父类静态变量（静态代码块）->子类静态变量（静态代码块）->父类非静态变量（非静态代码块）->父类构造器 ->子类非静态变量（非静态代码块）->子类构造器 。")]),t._v(" "),s("h3",{attrs:{id:"分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[t._v("#")]),t._v(" 分类")]),t._v(" "),s("p",[s("strong",[t._v("成员变量在使用对象之前就加载好，而局部变量需要在类或对象调用方法时才会创建")]),t._v("。")]),t._v(" "),s("p",[t._v("个人认为，这种分类方式有点粗糙，以下是比较详细的变量分类方式：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/shug666/image/main/images/20200512211919973.png",alt:""}})]),t._v(" "),s("h3",{attrs:{id:"成员变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#成员变量"}},[t._v("#")]),t._v(" 成员变量")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/shug666/image/main/images/20200512212055721.png",alt:""}})]),t._v(" "),s("p",[t._v("在这里，成员变量分为类变量和实例变量。")]),t._v(" "),s("p",[s("strong",[t._v("类变量是类加载过程中的准备阶段就已经分配内存了，直至类被销毁，类变量的内存才会释放")]),t._v("。")]),t._v(" "),s("p",[t._v("而"),s("strong",[t._v("实例变量是在类的实例创建（创建对象）时存在直至实例被销毁")]),t._v("。")]),t._v(" "),s("p",[s("strong",[t._v("1 访问类变量")]),t._v("的方式有两种：类.类变量、实例.类变量。"),s("strong",[t._v("除了类本身可以对类变量进行修改外，类的实例也会对类变量进行修改，且其他实例也会看到变化")]),t._v("。")]),t._v(" "),s("p",[s("strong",[t._v("2 访问实例变量")]),t._v("的方式就只有一种：实例.实例变量。"),s("strong",[t._v("每个实例的实例变量都不对其他实例可见")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"局部变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#局部变量"}},[t._v("#")]),t._v(" 局部变量")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/shug666/image/main/images/20200512212340576.png",alt:""}})]),t._v(" "),s("p",[t._v("局部变量在此分为形参、方法局部变量和代码块局部变量。")]),t._v(" "),s("p",[s("strong",[t._v("1 形参是方法签名上的局部变量")]),t._v("，当对象调用方法时传入了实参，但是传入方法的过程中会创建一个"),s("strong",[t._v("形参，作为值传递的副本")]),t._v("。")]),t._v(" "),s("p",[s("strong",[t._v("2 方法局部变量是在方法中创建变量")]),t._v("。")]),t._v(" "),s("p",[t._v("3 而"),s("strong",[t._v("代码块局部变量，即类中定义好的代码块")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"六个变量的加载顺序如下"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#六个变量的加载顺序如下"}},[t._v("#")]),t._v(" 六个变量的加载顺序如下")]),t._v(" "),s("p",[t._v("通过上述对变量的介绍，可以得到答案。先看主函数有没有创建对象，有创建对象的话看对应类中代码块有没有输出语句，然后返回主函数，依次执行语句和访问方法。可以看出，这六个变量的加载顺序如下")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/shug666/image/main/images/20200512213055706.png",alt:""}})]),t._v(" "),s("h3",{attrs:{id:"但是这六种变量为什么是这样的加载顺序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#但是这六种变量为什么是这样的加载顺序"}},[t._v("#")]),t._v(" "),s("strong",[t._v("但是这六种变量为什么是这样的加载顺序？")])]),t._v(" "),s("p",[s("strong",[t._v("按虚拟机加载顺序划分变量类型")])]),t._v(" "),s("p",[t._v("我们用"),s("strong",[t._v("类加载->创建对象->调用方法")]),t._v("的顺序来介绍变量的加载顺序。")]),t._v(" "),s("p",[s("strong",[t._v("类加载")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/shug666/image/main/images/2020051221324312.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("创建对象")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/shug666/image/main/images/20200512213320729.png",alt:""}})]),t._v(" "),s("p",[t._v("而"),s("strong",[t._v("实例变量和实例代码块是在创建对象后，进行对象初始化的时候才加载到内存中")]),t._v("。")]),t._v(" "),s("p",[s("strong",[t._v("调用方法")])]),t._v(" "),s("p",[t._v("在调用有参函数的时候，虚拟机会将实参复制后，生成形参，实参和形参的值相同，但是内存地址不同，即"),s("strong",[t._v("形参相对于实参来说，只是另一个有着同样的值的变量")]),t._v("。")]),t._v(" "),s("p",[t._v("所以在有参函数调用的过程中，"),s("strong",[t._v("形参先于方法局部变量被加载")]),t._v("。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/shug666/image/main/images/20200512213428540.png",alt:""}})]),t._v(" "),s("h3",{attrs:{id:"创建位置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建位置"}},[t._v("#")]),t._v(" 创建位置")]),t._v(" "),s("p",[t._v("方法区：类信息、类变量（静态变量和常量）、方法")]),t._v(" "),s("p",[t._v("堆：对象、成员变量")]),t._v(" "),s("p",[t._v("栈：局部变量")]),t._v(" "),s("p",[t._v("（1）当程序运行时，首先通过类装载器加载字节码文件，经过解析后装入方法区！在方法区中存了类的各种信息，包括类变量、常量及方法。对于同一个方法的调用，同一个类的不同实例调用的都是存在方法区的同一个方法。类变量的生命周期从程序开始运行时创建，到程序终止运行时结束！")]),t._v(" "),s("p",[t._v("（2）当程序中new一个对象时，这个对象存在堆中，对象的变量存在栈中，指向堆中的引用！对象的成员变量都存在堆中，当对象被回收时，对象的成员变量随之消失！")]),t._v(" "),s("p",[t._v("（3）当方法调用时，JVM会在栈中分配一个栈桢，存储方法的局部变量。当方法调用结束时，局部变量消失！")]),t._v(" "),s("p",[t._v("本文转自 "),s("a",{attrs:{href:"https://www.codenong.com/cs106085393/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.codenong.com/cs106085393/"),s("OutboundLink")],1),t._v("，如有侵权，请联系删除。")])])}),[],!1,null,null,null);s.default=a.exports}}]);