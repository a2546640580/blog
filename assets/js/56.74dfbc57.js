(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{510:function(e,o,r){"use strict";r.r(o);var n=r(0),p=Object(n.a)({},(function(){var e=this,o=e._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("p",[e._v("Android中的Looper类，是用来封装消息循环和消息队列的一个类，用于在android线程中进行消息处理。")]),e._v(" "),o("p",[e._v("handler其实可以看做是一个工具类，用来向消息队列中插入消息的。")]),e._v(" "),o("ol",[o("li",[o("p",[e._v("Looper类用来为一个线程开启一个消息循环。     默认情况下android中新诞生的线程是没有开启消息循环的。（主线程除外，主线程系统会自动为其创建Looper对象，开启消息循环。）     Looper对象通过MessageQueue来存放消息和事件。一个线程只能有一个Looper，对应一个MessageQueue。")])]),e._v(" "),o("li",[o("p",[e._v("通常是通过Handler对象来与Looper进行交互的。Handler可看做是Looper的一个接口，用来向指定的Looper发送消息及定义处理方法。     默认情况下Handler会与其被定义时所在线程的Looper绑定，比如，Handler在主线程中定义，那么它是与主线程的Looper绑定。 mainHandler = new Handler() 等价于new Handler（Looper.myLooper()）. Looper.myLooper()：获取当前进程的looper对象，类似的 Looper.getMainLooper() 用于获取主线程的Looper对象。")])]),e._v(" "),o("li",[o("p",[e._v("在非主线程中直接new Handler() 会报如下的错误: E/AndroidRuntime( 6173): Uncaught handler: thread Thread-8 exiting due to uncaught exception E/AndroidRuntime( 6173): java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare() 原因是非主线程中默认没有创建Looper对象，需要先调用Looper.prepare()启用Looper。")])]),e._v(" "),o("li",[o("p",[e._v("Looper.loop(); 让Looper开始工作，从消息队列里取消息，处理消息。")]),e._v(" "),o("p",[e._v("注意：写在Looper.loop()之后的代码不会被执行，这个函数内部应该是一个循环，当调用mHandler.getLooper().quit()后，loop才会中止，其后的代码才能得以运行。")])])])])}),[],!1,null,null,null);o.default=p.exports}}]);